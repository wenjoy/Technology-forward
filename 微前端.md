目前流行的微前端框架有两个single spa和qiankun。qiankun是基于single spa封装，达到开箱即用的便利程度。这篇介绍single spa和qiankun的区别：https://juejin.cn/post/6885211340999229454

### 用iframe引用也是一种微前端的方式，而且天然的js沙箱和样式隔离，那么为什么不用iframe呢？

1. iframe不能使用浏览历史记录，后退前进不能用。//利用localstorage，主应用url通过postmessage传给子iframe
2. iframe中的全局弹框只会基于iframe定位，不能居中//主应用做弹窗，但是这样耦合会很重
3. 性能问题，每次子应用进入都需要重建浏览器上下文，重新加载资源
4. 不能实现主应用cookie透传给子应用，实现免登录

参考：https://www.yuque.com/kuitos/gky7yw/gesexv

### qiankun使用经验

子应用要做两件事：

1. 打包方式改变
   1. 主应用要能读取到对应的生命周期，比如`mount`, `bootstrap` 
   2. 要打包成umd模式，一个唯一的bundle文件
2. 解决跨域问题

主应用要调用注册子应用

```js
import { registerMicroApps, start } from 'qiankun';

registerMicroApps([
  {
    name: 'react app', // app name registered
    entry: '//localhost:7100',
    container: '#yourContainer',
    activeRule: '/yourActiveRule', 如果主应用是这个path就会去entry用fetch加载bundlejs，然后把mount返回的dom挂载在container里
  },
  {
    name: 'vue app',
    entry: { scripts: ['//localhost:7100/main.js'] },
    container: '#yourContainer2',
    activeRule: '/yourActiveRule2',
  },
]);

start();
```

也可以手动加载

```js
手动加载微应用
loadMicroApp(app, configuration?)
```

#### 主子应用搭配使用还要注意样式隔离和js沙箱的问题，这两个问题qiankun也都有相应的解决方案

> 当配置为 `{ strictStyleIsolation: true }` 时表示开启严格的样式隔离模式。这种模式下 qiankun 会为每个微应用的容器包裹上一个 [shadow dom](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM) 节点，从而确保微应用的样式不会对全局造成影响
>
> qiankun 还提供了一个实验性的样式隔离特性，当 experimentalStyleIsolation 被设置为 true 时，qiankun 会改写子应用所添加的样式为所有样式规则增加一个特殊的选择器规则来限定其影响范围，因此改写后的代码会表达类似为如下结构：
>
> ```javascript
> // 假设应用名是 react16
> .app-main {
>   font-size: 14px;
> }
> 
> 
> div[data-qiankun-react16] .app-main {
>   font-size: 14px;
> }
> ```

但是好像还是有一些问题，还没有亲身经历过，比如子应用的弹窗，因为插入到了主应用，会导致样式丢失？

结合这两篇文章来看：

 [qiankun的css样式污染解决方案](https://juejin.cn/post/6992944363798003743) 

[记录使用 qiankun 遇到的一些问题](https://www.xiaoboy.com/topic/202110241730.html) 

js实现沙箱的原理，利用iframe或者代理。可以参考：https://juejin.cn/post/6981374562877308936

#### 主子应用间通信https://qiankun.umijs.org/zh/api#initglobalstatestate：

主应用：

```ts
import { initGlobalState, MicroAppStateActions } from 'qiankun';


// 初始化 state
const actions: MicroAppStateActions = initGlobalState(state);


actions.onGlobalStateChange((state, prev) => {
  // state: 变更后的状态; prev 变更前的状态
  console.log(state, prev);
});
actions.setGlobalState(state);
actions.offGlobalStateChange();
```

微应用：

```ts
// 从生命周期 mount 中获取通信方法，使用方式和 master 一致
export function mount(props) {
  props.onGlobalStateChange((state, prev) => {
    // state: 变更后的状态; prev 变更前的状态
    console.log(state, prev);
  });


  props.setGlobalState(state);
}
```