0.1+0.2=0.30000004 这个问题不是js一家语言的问题，https://0.30000000000000004.com/ 甚至有一个专门的网站，收录了各种在这个问题上阵亡的语言，可以看到，无一幸免。

这件事情发生的本质是，数学上无穷的概念在计算机工程里面落地，必须有取舍。举个例子，无限小数，1/3 or 1/7。为了最大效率，最高的精度，订立了专门的协议[IEEE754](https://standards.ieee.org/standard/754-2008.html), 具体来说就是用8个字节，即64位来表示浮点数。

64位比特又可分为三个部分：

- 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
- 指数位E：中间的 11 位存储指数（exponent），用来表示次方数
- 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

公式如下：

![latex expression](https://user-images.githubusercontent.com/948896/31601625-1f199ad0-b220-11e7-9d46-bb48a470bedf.png)

形象一点是这样的：

![preview](https://pic3.zhimg.com/v2-5036be957a2d50373ca74e83bad3e8be_r.jpg)

还有一点是， E是一个无符号整数，因为长度是11位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，这里没有用符号位，而是用了个中间数1023，[0,1022]表示为负，[1024,2047] 表示为正。

比如4表示成二进制2^2，因为是正的指数，所以加上1023，E=1025. 储存的时候就是1025，计算成十进制的时候再减去1023. 同理，如果是2^-2, 那么E=1023-2=1021.

这里要补充一点，十进制的小数是怎么转化成二进制小数的，这也是我之前看别人文章，老是搞不懂的地方，为什么 4.5的二进制就是100.1，却没有解释怎么来的。

#### 整数转化成二进制--除余法

首先我们知道整数转化成二进制是除余法，比如11:

11/2 = 5 。。。1

5/2 = 2 。。。1

2/2 = 1 。。。0

一直到商小于2，不是0就是1。那么最高位就是2/2=1. 次高位是0， 以此类推 最终结果是`1011` 。

其实更加直观的解法是：

1   1   1  1 1 1

32 16 8 4 2 1

16>11>8, 那么包含一个8，第四位有一个1，剩下11-8=3. 3<4, 第三位为0，以此类推，可得出相同结果。除余法为什么倒排，最后得的是高位，是因为前面已经除了两次2， 那么后面一次其实等价于11/2^3=11/8=1 ... 3 。

#### 小数转化成二进制

这个其实跟整数是类似的道理。核心就是凑。但是这个反着来，我们知道小数点后面的位数越靠后是越小，在二进制里就是这样：

1       1      1   

0.5 0.25 0.125

比如0.5，就刚好是`0.1`，只要小数点后第一个是1， 刚刚好。那如果是0.75，那就刚好是`0.11` 。但是，如果是0.7 呢凑个0.5，还剩0.2，后面的越来越小，重点是稀疏的，不是连续的。所以这里开始出现问题了。

之前整型的时候我们有除余法，现在小数其实也有对应的方法。乘以2，如果整数部分大于1就减去，并计一位，小数部分继续，直到为0. 然后这里跟整型的区别是正序，不用倒排了。 比如0.75：

0.75 *2 = 1.5 ，减去1，得0.5

0.5*2 =1， 减去1，得0

刚刚好就`11` 。

再比如0.7：

0.7 *2 = 1.4 ，减去1，计1，得0.4

0.4*2 =0.8， 小于1，计0，得0.8

0.8*2=1.6， 减去1，计1，得0.6

0.6*2=1.2， 减去1，计1，得0.2

0.2*2=0.4， 小于1，计0，得0.4

噫， 怎么又回来了，这是个无限循环啊。。。

所以0.7的二进制就是10110011。。。这就是为啥小数会出现各种问题的原因了。同样的我们会发现0.1，0.2，0.3，0.4，0.6，0.7，0.8，0.9我们都是循环的，只有0.5是刚刚好凑整的。也就是我们只能精确记录0.5的二进制小数。惊不惊喜，意不意外。

#### toPrecision and toFixed

都是把number转化成string，并且按照位数截取，但是要注意， toPrecision 是指保留几位有效数字，也就是左起第一位不为零的，toFixed是指小数点后保留几位。而且toFixed四舍五入会有问题，比如：

1.005.toFixed(2) -> "1.00", 因为1.005在计算机里存的其实是1.00499999999

#### 大数问题

因为E的可以表示的最大值是1023， 所以能表示的最大值是M*2^1023< 2 * 2^1023, 超过这个数就不行了，Math.pow(2, 1024) 是Infinity。 这时候可以用[bignumber](https://github.com/MikeMcl/bignumber.js/)这个库，原理是用字符串存。 

最大精度问题

因为M的最值是53，所以能表示的数的最大位数，即精度是2^53=9007199254740992, 超过的话就不行了，比如：`n=9007199254740999 -> 9007199254741000` , 可以用这个库[number-precision](https://github.com/nefe/number-precision)

#### 为什么x=0.1显示的是0.1呢，不是不能精确保证吗

这是巧合，因为最大能保存精度是9007199254741000，16位。0.1 其实是0.10000000000000000555。默认情况下刚好截取了前边16位，全是零。`0.1.toPrecision(21) = 0.100000000000000005551` 就会看到，其实还是不能保证精确的。

ref：

1. [JavaScript 浮点数陷阱及解法 #9](https://github.com/camsong/blog/issues/9)